## 1. List
### 1.1 结构
#### 数组结构
      
含义：集合底层使用数组来存储数据
      
特点："数组结构"的查询效率相比"链表结构"高"；"数组结构"的增删效率相比"链表结构"低。

#### 链表结构
      
含义：其实就是Java程序中的"类",不断进行"套娃"的类
      
分类：
1. 单向链表结构。链表类含有至少两个属性：
   - 当前元素(泛型类型) 
   - 下一个链表对象(链表类的类型) 
2. 双向链表结构。链表类含有至少三个属性：
   - 当前元素(泛型类型) 
   - 下一个链表对象(链表类的类型) 
   - 上一个链表对象(链表类的类型)
            
特点：
- "链表结构"的查询效率相比"数组结构"要低
- "链表结构"的增删效率相比"数组结构"要高
- "链表结构"可以快速操作首尾两个链表对象
            
注意：链表结构越长，链表效率越低。

## 1.2 ArrayList类
类的特点：
1. ArrayList集合底层的数据结构是"数组结构"。
2. ArrayList集合是有序的集合。
3. ArrayList集合是含有索引的集合。
4. ArrayList集合可以存储重复元素。
5. ArrayList集合可以存储null元素。当遍历集合中的元素时，需要进行非空校验，防止使用元素时的空指针异常。
6. ArrayList集合是线程不安全的。适用于单线程程序，如果在多线程程序中进行使用，需要手动添加线程安全。
7. ArrayList集合遍历方式有6种
      
类的位置：java.util
      
类的构造器：`public ArrayList()`。构造一个初始容量为10的空列表。
      
类的方法：详见Collection接口和List集合的常用方法
      
应用场景：适用于针对集合中元素做"查询操作"较多的情况

ArrayList集合存储元素过程的源码分析(基于JDK8.0):
1. ArrayList集合底层数组的初始容量是多少？底层数组的初始容量是多少取决于创建对象时所选择的构造器
   - ArrayList()：初始容量:0
   - ArrayList(Collection<? extends E> c)：初始容量:参数集合的长度
   - ArrayList(int initialCapacity)：初始容量:自定义
2. 底层数组的扩容规则:
   - 当底层数组长度为0时，首次添加元素时：扩容规则--10
   - 非首次添加元素时：扩容规则--原来底层数组长度 + (原来底层数组长度 >> 1)
3. JDK6.0(包含)以前和JDK7.0(包含)以后的区别:
   - 无参构造器底层数组的初始容量不同。JDK6.0(包含)以前初始容量10；JDK7.0(包含)以后初始容量0 
   - 扩容规则不同。
     - JDK6.0(包含)以前，扩容规则：(原来底层数组长度  3)/2 + 1；
     - JDK7.0(包含)以后当底层数组长度为0时，扩容规则：10 
     - 当底层数组长度非0时，扩容规则：原来底层数组长度 + (原来底层数组长度 >> 1)

### 1.3 Vector类:
类的特点： 
1. Vector集合底层的数据结构是"数组结构"。
2. Vector集合是有序的集合。
3. Vector集合是含有索引的集合。
4. Vector集合可以存储重复元素 。
5. Vector集合可以存储null元素。当遍历集合中的元素时，需要进行非空校验，防止使用元素时的空指针异常。
6. Vector集合是线程安全的。适用于多线程程序，如果在单线程程序中进行使用，效率过低。
7. Vector集合遍历方式有6种。
      
类的位置：java.util
      
类的构造器：`public Vector()`.构造一个空向量，使其内部数据数组的大小为10，其标准容量增量为零。
      
类的方法：详见Collection集合和List集合的常用方法
      
应用场景：适用于针对集合中元素做"查询操作"较多的情况，且仅使用与多线程环境。

Vector集合存储元素过程的源码分析:
1. Vector集合底层数组的初始容量和初始增量是多少？底层数组的初始容量和初始增量是多少取决于创建对象时所选择的构造器
   - Vector()：初始容量--10；初始增量--0。
   - Vector(Collection<? extends E> c)：初始容量--参数集合的长度；初始增量--0
   - Vector(int initialCapacity)：初始容量--自定义；初始增量--0
   - Vector(int initialCapacity, int capacityIncrement)：初始容量--自定义；初始增量--自定义
2. Vector集合底层数组的扩容扩展：
   - 当初始增量为小于等于0时，扩容规则：原来底层数组长度 + 原来底层数组长度
   - 当初始增量大于0时，扩容规则：原来底层数组长度 + 初始增量

### 1.4 LinkedList类
类的特点： 
1. LinkedList集合底层的数据结构是"双向链表结构"
2. LinkedList集合是有序的集合
3. LinkedList集合是含有索引的集合
4. LinkedList集合可以存储重复元素
5. LinkedList集合可以存储null元素。当遍历集合中的元素时，需要进行非空校验，防止使用元素时的空指针异常
6. LinkedList集合是线程不安全的。适用于单线程程序，如果在多线程程序中进行使用，需要手动添加线程安全
7. LinkedList集合遍历方式有6种
      
类的位置：java.util
      
类的构造器：`public LinkedList()`。构造一个空列表。
      
类的方法：
- `public void addFirst(E e)`：将指定元素插入此列表的开头。 
- `public void addLast(E e)`：将指定元素添加到此列表的结尾。 
- `public E removeFirst()`：移除并返回此列表的第一个元素。 
- `public E removeLast()`：移除并返回此列表的最后一个元素。 
- `public E getFirst()`：返回此列表的第一个元素。
- `public E getLast()`：返回此列表的最后一个元素。

LinkedList存储元素过程的源码分析:

## 2. Set
### 2.1 Set接口
接口的特点： 
1. Set集合不可以存储重复元素
2. Set集合中既有有序集合,也有无序集合
3. Set集合没有索引
4. Set集合遍历方式有4种
      
接口的位置：java.util
      
接口的方法：详见Collection集合的常用方法

### 2.2 HashSet类
类的特点：
1. HashSet集合底层封装一个HashMap实例，HashMap集合底层数据结构是"哈希表结构"。哈希表结构:
   - JDK7.0(包含)以前：哈希表结构是存储链表对象的数组
   - JDK8.0(包含)以后：哈希表结构是存储链表对象或红黑树对象的数组
2. HashSet集合是无序的集合
3. HashSet集合无法保证存储集合中元素的顺序永远不会改变。原因：元素的顺序和底层数组的长度有关，一旦底层数组长度改变，元素在集合中的位置就有可能发生变化。
4. HashSet集合可以存储null元素，获取集合中元素时需要进行非空校验，防止使用元素时出现空指针异常。
5. HashSet集合是线程不安全，适用于单线程程序，如果在多线程中进行使用需要手动添加线程安全。
         
类的位置：java.util
         
类的构造器：`public HashSet()`：构造一个新的空set，其底层HashMap实例的默认初始容量是16，加载因子是0.75。
         
类的方法：详见Collection接口的常用方法。

HashSet集合面试题1：HashSet集合如何保证元素的唯一性
1. 和存储元素对象的地址值无关
2. 重写Object类的hashCode();
3. 重写Object类的equals();

HashSet集合面试题2：String类重写hashCode方法时，计算的中间量为什么是31?
1. 该数不宜过大，也不宜过小(过小增大hashCode重复概率，过大增加计算量)
2. 该数的因数不宜过多，推荐质数
3. 通过"泊松分布"，获取到质数29和31是较为合适的数字
4. 因为29可以改写成2^5-3，31可以改写为2^5-1，更符合整数取值范围的格式，最终确定为31
