## 1. 抽象
含义：抽象其实就是为了解决继承关系中的安全隐患

分类：抽象类、抽象方法

继承关系中的安全隐患：
1. 在继承关系中，父类是多个子类抽取出来的共同属性和行为，希望该类在外界不可以被创建成对象，实际上可以被创建对象。
2. 在继承关系中，子类重写父类的方法，最终执行的是子类重写后的方法。不会执行父类被重写方法中的内容，希望声明父类被重写方法的时候，无需编写方法体，实际上如果不写方法体，编译报错。
3. 在继承关系中，子类重写父类的方法，程序员可能忘记某个字节重写父类的方法。希望忘记重写时，编译报错进行提示，实际上忘记重写没有任何提示

### 1.1 抽象类:
含义：被abstract关键字修饰的父类，也称之为抽象父类（加强版父类）。
     
格式：`public abstract 父类类名 {}`
     
注意事项：
1. 抽象类不可以被实例化对象 
2. 抽象类中可以含有构造器，构造器的作用用来创建子类对象时，初始化父类成员。

### 1.2 抽象方法:
含义：被abstract修饰且没有方法实体的方法
     
格式：`修饰符 abstract 返回类型 方法名();`
     
注意事项：
1. 抽象类中可以没有抽象方法，但是含有抽象方法的类一定是抽象类。
2. 抽象类的子类必须重写抽象父类中的所有抽象方法，否则编译报错。除非该子类也是抽象类。 

## 2. 继承
### 2.1 权限访问级别基础应用小结
- 类文件(class,interface,enum)
限访问级别：public和缺省，推荐public
     
- 类中的成员量
权限访问级别：四种都可以，推荐private
     
- 类中的成员方法
权限访问级别，四种都可以，推荐public和private
     
- 类中的成员内部类
权限访问级别：四种都可以，推荐private和缺省
     
- 类中的构造器
权限访问级别：四种都可以，推荐public和private
     
- 类中的构造器代码块
权限访问级别：只能缺省
     
- 类中的静态代码块
权限访问级别：只能缺省
     
- 接口中的静态常量、抽象方法、默认方法、静态方法、内部接口
权限访问级别：只能public，无论显式还是隐式都是public
     
- 接口中的私有方法
权限访问级别：只能private
     
- 枚举类中的枚举对象
权限访问级别：只能是public，而且必须是隐式的public
     
- 枚举类中的成员量(除枚举对象):
权限访问级别：四种都可以，推荐private
     
- 枚举类中的成员方法
权限访问级别,：四种都可以，推荐public和private
     
- 枚举类中的成员内部类
权限访问级别：四种都可以，推荐private和缺省
     
- 枚举类中的构造器 
权限访问级别：只能private，无论显式还是隐式都是private
     
- 枚举类中的构造器代码块 
权限访问级别：只能缺省
     
- 枚举类中的静态代码块
权限访问级别：只能缺省
     
- 局部成员
权限访问级别：只能缺省

### 2.2 回顾this关键字第一种用法:
     
场景：子类的构造器中或子类的实例方法中

格式：`this.实例变量名;` `this.实例方法名(实参);`
     
作用：用来区分同一个类中同名的实例变量和局部变量
     
含义：哪个对象调用了this关键字所在的实例方法或构造器，this关键字就代表哪个对象

### 2.3 super关键字第一种用法:
场景：子类的构造器中或子类的实例方法中
     
格式：`super.实例变量名;` `super.实例方法名(实参);`
     
作用：
- 用来区分子父类继承关系中同名的实例变量 
- 用来区分子父类继承关系中重写的实例方法
     
含义：哪个对象调用了super关键字所在的实例方法或构造器，super关键字就代表哪个对象的父类引用

### 2.4 方法的重写
     
含义：在子父类继承关系中(或实现关系中)，出现了方法名相同，形参列表相同，权限访问级别和返回类型遵循相关规则的现象
     
目的：
1. 为了后期进行功能的扩展 
2. 方法的重写是学习多态,接口,匿名内部类的核心条件

前提条件：
- 必须存在子父类继承关系(或实现关系)
- 父类被重写方法和子类重写后方法的方法名必须相同
- 父类被重写方法和子类重写后方法的形参列表必须相同
- 子类重写后方法的权限访问级别必须大于等于父类被重写方法,且遵循权限访问级别的修饰范围(详见方法重写的注意事项)
- 子类重写后方法的返回类型和父类被重写方法的返回类型在内存中必须相同
     
注意事项：
1. Java语言针对方法的重写提供了语法格式检测工具(方法重写的注解)，验证是否满足方法重写的条件

方法重写注解:
- 含义：用来验证子类方法是否满足方法重写的条件，如果不满足"编译报错"
- 位置：子类中 
- 格式：

```java
@Override
修饰符 返回类型 方法名() {}
```
         2.父类的私有方法不可以被重写
         3.子父类不在同一个包下,父类的缺省方法不可以被子类进行重写
         4.父类的静态方法不可以被重写,编写代码时需要遵循方法重写前提条件
         5.子类重写后方法的返回类型在代码中:
             如果当父类的返回类型为void时,子类重写后方法的返回类型也必须是void;
             如果当父类的返回类型为基本类型时,子类重写后方法的返回类型也必须是该基本类型;
             如果当父类的返回类型为引用类型时,子类重写后方法的返回类型也必须是该引用类型或该引用类型的子类类型
