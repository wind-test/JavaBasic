## 1. 抽象
含义：抽象其实就是为了解决继承关系中的安全隐患

分类：抽象类、抽象方法

继承关系中的安全隐患：
1. 在继承关系中，父类是多个子类抽取出来的共同属性和行为，希望该类在外界不可以被创建成对象，实际上可以被创建对象。
2. 在继承关系中，子类重写父类的方法，最终执行的是子类重写后的方法。不会执行父类被重写方法中的内容，希望声明父类被重写方法的时候，无需编写方法体，实际上如果不写方法体，编译报错。
3. 在继承关系中，子类重写父类的方法，程序员可能忘记某个字节重写父类的方法。希望忘记重写时，编译报错进行提示，实际上忘记重写没有任何提示

### 1.1 抽象类:
含义：被abstract关键字修饰的父类，也称之为抽象父类（加强版父类）。
     
格式：`public abstract 父类类名 {}`
     
注意事项：
1. 抽象类不可以被实例化对象 
2. 抽象类中可以含有构造器，构造器的作用用来创建子类对象时，初始化父类成员。

### 1.2 抽象方法:
含义：被abstract修饰且没有方法实体的方法
     
格式：`修饰符 abstract 返回类型 方法名();`
     
注意事项：
1. 抽象类中可以没有抽象方法，但是含有抽象方法的类一定是抽象类。
2. 抽象类的子类必须重写抽象父类中的所有抽象方法，否则编译报错。除非该子类也是抽象类。 

## 2. 继承
### 2.1 权限访问级别基础应用小结
- 类文件(class,interface,enum)
限访问级别：public和缺省，推荐public
     
- 类中的成员量
权限访问级别：四种都可以，推荐private
     
- 类中的成员方法
权限访问级别，四种都可以，推荐public和private
     
- 类中的成员内部类
权限访问级别：四种都可以，推荐private和缺省
     
- 类中的构造器
权限访问级别：四种都可以，推荐public和private
     
- 类中的构造器代码块
权限访问级别：只能缺省
     
- 类中的静态代码块
权限访问级别：只能缺省
     
- 接口中的静态常量、抽象方法、默认方法、静态方法、内部接口
权限访问级别：只能public，无论显式还是隐式都是public
     
- 接口中的私有方法
权限访问级别：只能private
     
- 枚举类中的枚举对象
权限访问级别：只能是public，而且必须是隐式的public
     
- 枚举类中的成员量(除枚举对象):
权限访问级别：四种都可以，推荐private
     
- 枚举类中的成员方法
权限访问级别,：四种都可以，推荐public和private
     
- 枚举类中的成员内部类
权限访问级别：四种都可以，推荐private和缺省
     
- 枚举类中的构造器 
权限访问级别：只能private，无论显式还是隐式都是private
     
- 枚举类中的构造器代码块 
权限访问级别：只能缺省
     
- 枚举类中的静态代码块
权限访问级别：只能缺省
     
- 局部成员
权限访问级别：只能缺省

### 2.2 this和super
#### this关键字第一种用法:
     
场景：子类的构造器中或子类的实例方法中

格式：`this.实例变量名;` `this.实例方法名(实参);`
     
作用：用来区分同一个类中同名的实例变量和局部变量
     
含义：哪个对象调用了this关键字所在的实例方法或构造器，this关键字就代表哪个对象

#### this关键字的第二种用法:
场景：子类的构造器中

格式：`this(实参);`

作用：调用本类中其它的构造器

含义：当构造器无法进行初始化(人为操作)时，使用this(实参)调用本类中其它的构造器完成对象成员的初始化操作。

#### super关键字第一种用法:
场景：子类的构造器中或子类的实例方法中
     
格式：`super.实例变量名;` `super.实例方法名(实参);`
     
作用：
- 用来区分子父类继承关系中同名的实例变量 
- 用来区分子父类继承关系中重写的实例方法
     
含义：哪个对象调用了super关键字所在的实例方法或构造器，super关键字就代表哪个对象的父类引用

#### super关键字的第二种用法:
场景：子类的构造器中

格式：`super(实参);`

作用：调用父类中的构造器

含义：创建子类对象时，初始化子类成员前，先初始化父类的成员

this关键字和super关键字的注意事项
1. this关键字在内存中是含有地址值的，可以直接进行打印操作，但是super关键字在内存中只能子类对象地址值中的一部分，没有独立的地址值，super关键字无法进行打印操作。
2. 在静态成员中无法使用this关键字和super关键字
3. 在构造器中,super(实参)和this(实参)必须在第一行
4. 在同一个构造器中,super(实参)和this(实参)不可以同时调用

### 2.3 方法的重写
     
含义：在子父类继承关系中(或实现关系中)，出现了方法名相同，形参列表相同，权限访问级别和返回类型遵循相关规则的现象
     
目的：
1. 为了后期进行功能的扩展 
2. 方法的重写是学习多态,接口,匿名内部类的核心条件

前提条件：
- 必须存在子父类继承关系(或实现关系)
- 父类被重写方法和子类重写后方法的方法名必须相同
- 父类被重写方法和子类重写后方法的形参列表必须相同
- 子类重写后方法的权限访问级别必须大于等于父类被重写方法,且遵循权限访问级别的修饰范围(详见方法重写的注意事项)
- 子类重写后方法的返回类型和父类被重写方法的返回类型在内存中必须相同
     
注意事项：
1. Java语言针对方法的重写提供了语法格式检测工具(方法重写的注解)，验证是否满足方法重写的条件

方法重写注解:
- 含义：用来验证子类方法是否满足方法重写的条件，如果不满足"编译报错"
- 位置：子类中 
- 格式：

```
@Override
修饰符 返回类型 方法名() {}
```
2. 父类的私有方法不可以被重写
3. 子父类不在同一个包下，父类的缺省方法不可以被子类进行重写
4. 父类的静态方法不可以被重写，编写代码时需要遵循方法重写前提条件
5. 子类重写后方法的返回类型在代码中:
- 如果当父类的返回类型为void时，子类重写后方法的返回类型也必须是void。
- 如果当父类的返回类型为基本类型时，子类重写后方法的返回类型也必须是该基本类型; 
- 如果当父类的返回类型为引用类型时，子类重写后方法的返回类型也必须是该引用类型或该引用类型的子类类型

### 2.4 继承关系中构造器的特点
1. 子类无法继承父类的构造器 
2. 当构造器没有任何的super(实参)或者this(实参)时，JVM的编译器自动在构造器中填补一个super()，用来创建子类对象的同时，初始化子类对象的父类成员。

## 3. final

### 3.1 final关键字
      
含义：最终的，不可改变的。
      
修饰：类、方法、变量
      
作用：
1. 被final修饰的类，被称之"最终类、不可改变类"，不能被继承。
   - 场景：在开发中，某些类仅提供使用，并不想被修改，将其声明为最终类。
   - 注意：final关键字和abstract关键字不可以修饰同一个类。
2. 被final修饰的方法，被称之"最终方法、不可改变方法"，不能被重写 。
   - 场景：在实际开发中，一个类的某个或某些方法不想被子类所重写，将其声明为最终方法。 
   - 注意：final关键字和abstract关键字不可以同时修饰一个方法
3. 被final修饰的变量，被称之"自定义常量"，不能被二次赋值
   - 场景：在实际开发中需要使用不可改变且带有数据类型的常量时。
   - 分类：自定义局部常量、自定义实例常量、自定义静态常量。
   - 注意：
     - JVM的编译器会将被final修饰且通过直接声明初始化的常量，当成字面值常量进行编译和使用； 
     - 常量有常量的命名规范：一个单词（单词字母全部大写）；多个单词（每个单词字母全部大写，且每个单词间使用_进行连接）

## 4. Object类
      
### 4.1 类的特点
1. Object类是所有类的顶级父类
2. 所有的对象(包括数组)都可以调用Object类中的方法
3. 所有的接口都继承Object类中方法的抽象形式(暂不涉及)
      
类的位置：java.lang
      
类的构造器：`public Object()`
      
类的方法：
- `public String toString()`：返回该对象的字符串表示。
- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。

toString()的注意事项： 使用输出语句打印对象名或数组名时，其实就是打印该对象或数组调用toString()的返回值，char类型数组除外。

### 4.2 ==和equals()的区别:
1. 比较内容的数据类型不同：
   - ==既可以比较基本类型数据，也可以比较引用类型数据。 
   - equals()只能比较引用类型数据
2. 比较内容的方式不同：
   - ==比较基本类型数据时，比较的是基本类型的数据值是否相等；而比较引用类型时，比较的是引用类型的地址值是否相等。
   - equals()比较的是引用类型的地址值是否相等，如果调用equals()是重写Object类后的方法，需要按照重写后的规则进行比较。
