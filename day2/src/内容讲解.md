## 1. 类型的转换
含义：将一种数据类型的数据转换为另外一种数据类型的数据

分类：基本类型的类型转换、引用类型的类型转换（暂不涉及）、基本类型和包装类型的类型转换（暂不涉及）、基本类型和字符串类型的类型转换（暂不涉及）

### 1.1 基本类型的类型转换
含义：将一种基本类型的数据转换为另外一种基本类型的数据。

分类：自动转换（隐式转换）、强制转换（显式转换）

格式：`数据类型1 变量名 = (数据类型1)数据类型2的变量值;`

### 1.2 自动转换（隐式转换）

含义：将取值范围较小的数据类型转换成取值范围较大的数据类型 

基本类型取值范围从小到大的关系：

	byte < short < int < long < float < double
	char < int < long < float < double

注意：

	1. 基本类型间的转换是七种数值类型间的转换,boolean类型无法进行转换
	2. 动转换也可以使用类型转换的格式,往往将(数据类型)省略不写

在内存中，每创建一个float类型变量，占内存4个字节；每创建一个long类型变量，占内存8个字节。

为什么float类型可以存储long类型数据? 

	1. 基本类型的类型转换只与数据类型的取值范围有关,和所在内存大小无关
	2. float类型之所有可以用更少的字节存储更大或更小的数据,因为float或double底层不是十进制小数,而是一套IEEE754浮点计数标准
	3. 证明long的取值范围小于float的取值范围
		long的取值范围中最大的整数 < 2^63
		float的取值范围中最大的整数 > 3.4*10^38 > 2*10^38 > 2*8^38 = 2*(2^3)^38 = 2*2^114 = 2^115 > 2^63

### 1.3 基本类型的强制类型(显式转换)
含义: 将取值范围较大的数据类型转换成取值范围较小的数据类型。

格式: `取值范围较小的数据类型 变量名 = (取值范围较小的数据类型)取值范围较大数据类型的变量值;`。

注意：在实际应用中尽量避免使用基本类型的强制转换,可能会发生数据的精度损失或数据溢出。

基本类型的类型转换注意事项：

	1. 类型类型的自动转换和强制转换都可以使用基本类型转换的格式，自动转换可以省略不写(数据类型); 
	2. 基本类型间的转换是七种数值类型间的转换，boolean类型无法进行转换；
	3. 在实际应用中尽量避免使用基本类型的强制转换，可能会发生数据的精度损失或数据溢出； 
	4. byte,short,char这三种基本类型只要参与数学运算,先自动提升成int类型,再参与数学运算;如果没有数学运算,依旧按照基本类型的自动转换关系进行转换。

## 2. 输出语句

### 2.1 换行输出语句:
含义：将内容进行输出打印，并进行回车换行操作

格式：`System.out.println(内容);`

注意：当换行输出语句没有任何输出内容时，直接进行换行处理

### 2.2 直接输出语句
含义：将内容进行输出打印，不进行其它操作。

格式：`System.out.print(内容);`

注意：当直接输出语句没有任何输出内容时，程序"编译报错"。

## 3. 常量
含义：在程序执行的过程中,其值不可以发生改变的量。 

### 3.1 常量的分类

**自定义常量（暂不涉及）**
含义：由开发人员定义的常量,并且有final关键字进行修饰。

**字面值常量**
含义：单独的数据值,无法直接进行使用,需要结合其它语句进行使用。

分类：整数字面值常量、浮点字面值常量、字符字面值常量、布尔字面值常量、字符串字面值常量、空常量（暂不涉及）、null。

注意：字面值常量无法单独使用，需要结合其它语句进行使用；null无法在输出语句中进行打印。

### 3.2 常量的注意事项:
	1. 在给byte、short、char这三种数据类型进行整数赋值操作时，初始化值如果是字面值常量，且该初始化值还在其数据类型的取值范围内，JVM中的存储常量的内存区域会将其自动优化为该数据类型，将这一过程称之为"常量优化机制"。
	2. 在给变量进行初始化赋值操作时，如果初始化值是一个表达式，运算符号两边的数据都是字面值常量，且运算的结果还在其数据类型的取值范围内，JVM中的编译器在编译器自动将其运算完毕，将这一过程称之为"常量优化机制"。

## 4. 运算符和表达式
运算符：在程序中用来连接常量或变量的运算符号；

表达式：在程序中用运算符连接起来的式子。

常见的运算符：算术运算符、赋值运算符、关系运算符、逻辑运算符、三元运算符、位运算符

### 4.1 算数运算符
含义：进行常量或变量算术操作的运算符。

分类：四则运算符（+ - * /）、 取余运算符（%）、自增运算符（++）、自减运算符（--）。

**四则运算符和取余运算符**

含义：针对常量或变量进行数学运算的运算符。

注意：
- /是获取两个数相除的商 
- 是获取两个数相除的余数

**+号的多种用法**
1. 加法运算符
2. 字符串连接符

当+号两边中的任意一边出现了字符串时，+号不再起到加法运算符的作用，而是变成了字符串连接符，将运算符两边的内容进行连接操作。

**自增自减运算符**

含义：在变量的自身数据基础上进行+1或-1的运算符。

注意：自增自减运算符只能变量进行使用，常量无法进行使用。
	格式（以++为例）：`++变量名` 或者 `变量名++`

单独使用：++在前和++在后的结果是一样的

复合使用：如果++在前，先自增，再使用； 如果++在后，先使用，在自增。

### 4.2 赋值运算符

含义：针对变量或操作进行赋值操作的运算符。

**直接赋值运算符** =

**复合赋值运算符** += -= *= /= %= ......

含义：将运算符两边的结果进行运算操作（取决于=之外的符号），再将运算的结果赋值给左边的变量。

注意：复合的赋值运算符再将左右两边运算的结果赋值给左边的变量之前，会根据左边变量的数据类型隐藏做了一步强制转换。

### 4.3 关系运算符
含义：比较变量或常量之间关系的运算符。

分类：< <= > >= == !=

注意：关系表达式的结果一定是boolean值

	==:比较基本类型数据值是否相等
	!=:比较基本类型数据值是否不等

### 4.4 逻辑运算符
含义：用来连接结果是boolean值表达式的运算符。

#### 4.4.1 单独逻辑运算符

**运算符&**

含义：与,且。

特点：有false则false。

场景：判断多个条件是否同时满足。

**运算符|**

含义：或。
			
特点：有true则true。
			
场景：判断多个条件是否至少满足其中一条。

**运算符^**
			
含义：异或。

特点：相同则false，不同则true。 

场景：判断多个条件结果是否不一致 

**运算符!**

含义：非。
			
特点：非true则false，非false则true。
			
场景：针对boolean值结果进行取反。

#### 4.4.2 短路逻辑运算符
&& ||

&和&&的区别：
- &和&&的结果是一样的；
- &&具有短路效果，当&&前面表达式的结果为false时，后面的表达式不会被执行；
- &无论前面表达式结果的值是true还是false，后面表达式都会被执行。

和||的区别：
- |和||的结果是一样的；
- ||具有短路效果，当||前面表达式的结果为true时，后面的表达式不会被执行；
- |无论前面表达式结果的值是true还是false,，后面表达式都会被执行。

### 4.5 三元运算符:
含义：含有三个未知量的运算符 

格式：`关系表达式 ? 结果值1 :结果值2`
		
流程:
1. 先确认关系表达式的结果是true还是false。
2. 获取关系表达式结果的同时，统一结果值1和结果值2的数据类型。
3. 果是true，执行"统一数据类型后的"结果值1；如果是false，执行"统一数据类型后的"结果值2。


## 5. 原码,反码,补码:
相同点:
1. 原码、反码、补码都是特殊的二进制形式表示法。
2. 原码、反码、补码在二进制数据中规定的符号位，最高位即为符号位。正数为0，负数为1。
3. 原码、反码、补码在二进制数据中根据在内存中占用字节大小进行足位存储，不足位数通过补0进行占位。

例如：int num = 2;

普通二进制：10

特殊二进制：00000000 00000000 00000000 00000010

不同点：
- 原码：计算机中显示数据的二进制特殊表示形式。 
- 补码：计算机中底层进行数据运算的二进制特殊表示形式。
- 反码：进行原码和补码相互转换的中间量。

层存储和操作数据的过程分析：
1. 显示数据==>数据原码
   - 根据显示数据占用字节数确定二进制的总位数。
   - 根据显示数据的正负确定二进制原码的符号位。
2. 数据原码==>数据反码 
   - 如果符号位是0，数据反码与其原码相同。
   - 如果符号位是1，数据反码在其原码的基础上进行逐位取反,符号位保持不变。
3. 数据反码==>数据补码
   - 如果符号位是0，数据补码与其反码相同。
   - 如果符号位是1，数据补码在其反码的基础上进行+1运算 
4. 操作补码==>结果补码
   - 据实际需求进行运算操作 
5. 结果补码==>结果反码
   - 如果符号位是0，结果反码与其补码相同。
   - 如果符号位是1，数据反码在其补码的基础上进行-1运算。
6. 结果反码==>结果原码 
   - 如果符号位是0，结果原码与其反码相同。
   - 如果符号位是1，数据原码在其反码的基础上进行逐位取反，符号位保持不变。 
7. 结果原码==>结果数据 
   - 将除符号位外，所有二进制数进行将十进制的转换。
   - 如果符号位是1，在十进制结果数据的前面补上负号。

将int类型的130强制转换成byte类型后，结果为-126的存储操作过程：
1. 显示数据==>数据原码
   - 数据原码:00000000 00000000 00000000 10000010 
2. 数据原码==>数据反码
   - 数据反码:00000000 00000000 00000000 10000010 
3. 数据反码==>数据补码
   - 数据补码:00000000 00000000 00000000 10000010 
4. 操作补码==>结果补码
   - 结果补码:10000010 
5. 结果补码==>结果反码
   - 结果反码:10000001 
6. 结果反码==>结果原码
   - 结果原码:11111110 
7. 结果原码==>结果数据
   - 结果数据:-126

## 6. 位运算符
含义：直接针对二进制位进行操作的运算符。

### 6.1 按位运算符:
**运算符&**

含义：按位与。

特点：当两位相同时为1时才返回1，包括符号位。

**运算符|**

含义：按位或
   
特点：当两位有一位为1即可返回1，包括符号位。

**运算符^**
   
含义：按位异或
   
特点：当两位相同时返回0，不同时返回1，包括符号位。


### 6.2 移位运算符
		
含义：移动二进制位操作的运算符。
		
分类：<< >> >>>

**左移运算符**
		
含义：将二进制位往左移动指定的位数，包含符号位。
		
格式：数据 << 位数。
		
特点：将二进制位往左移动指定的位数，符号位也随之移动，如果低位出现了空位，补0进行占位操作。
	
**右移运算符**
		
含义：将二进制位往右移动指定的位数，包含符号位。
		
格式：数据 >> 位数
		
特点：将二进制位往右移动指定的位数，符号位也随之移动，如果高位出现了空位，补和符号位相同的数字进行占位操作。

**无符号右移运算符**
		
含义：将二进制位往右移动指定的位数,无需关注符号位
		
格式：数据 >>> 位数
		
特点：将二进制位往右移动指定的位数,符号位也随之移动,如果高位出现了空位,补0进行占位操作
