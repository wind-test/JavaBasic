## 1. 枚举类
含义：创建固定数量对象简化方式。

枚举类的格式：
```
public enum 枚举类类名 {
  枚举对象名1(实参),枚举对象名2(实参),......,枚举对象名n(实参);
}
```

枚举类的注意事项：
1. 枚举是JDK5.0的新特性，JDK1.4（包含）以前无法进行使用。
2. 枚举类无法通过new实例化对象。
3. 当枚举类没有任何的构造器时，JVM的编译器自动填充一个私有无参的构造器，供其创建枚举对象进行使用；一旦枚举含有任何的构造器，JVM的编译器不会提供。
4. 枚举类的构造器权限访问级别只能是私有，但private可以省略不写，JVM的编译器会在编译时期进行填充。
5. 在枚举类中使用无参构造器创建枚举对象时，枚举对象后的()可以省略不写。
6. 在程序中所有的枚举类都直接隐式继承Enum类。
7. 在程序中所有的枚举类无法直接显示继承其它类，唯一单继承继承了Enum类。
8. 枚举类可以直接显示实现多个接口。
9. 在程序中所有的枚举类不能拥有子类。
10. 在枚举类的构造器中无法使用super（实参）访问Enum类的构造器。
11. 在程序中所有的枚举类中一旦有内容，必须声明枚举对象，省略private的无参构造器除外。
12. 在程序中所有枚举对象必须声明在枚举类的第一行。
13. 枚举类中所有枚举对象都被隐式修饰成public static final，但是显式修饰编译报错。
14. 因为枚举类中所有枚举对象被隐式的final修饰，所需枚举对象是常量，枚举对象名遵循常量的命名方式。

## 2. 初始化
### 2.1 初始化过程:
含义：“实例初始化过程”和“类初始化过程”的统称。
      
分类：
1. 实例初始化过程。 
   - 含义：对象创建后的成员初始化过程。
2. 类初始化过程
   - 含义：字节码对象创建后的成员初始化过程。

### 2.2 实例初始化
没有继承关系的实例初始化过程：
1. 隐式加载实例成员和构造器代码块（实例成员和构造器代码块优先级一样，谁在前优先加载谁）。
2. 构造器中的显式代码（除了显式的`super(实参)`和`this(实参)`）。

含有继承关系的实例初始化过程：
1. 显式或隐式的`super(实参)`
2. 隐式加载实例成员和构造器代码块（实例成员和构造器代码块优先级一样，谁在前优先加载谁）
3. 构造器中的显式代码（除了显式的`super(实参)`和`this(实参)`）

this关键字的第三种用法：

场景：父类的构造器中或实例方法中，成员。

格式：
- `this.实例变量名;`
- `this.实例方法名(实参);`
      
作用：多态形式的子类对象。
      
含义：该this关键字就代表所在父类类型的子类对象。

## 2.3 类初始化
没有继承关系的类初始化过程：静态成员和静态代码块加载的优先级一样，谁在前就优先加载谁。

含有继承关系的类初始化过程：先加载父类的静态成员和静态代码块，然后加载子类的静态成员和静态代码块。

## 3. 内部类
### 3.1 概念
含义：在一个类中声明另外的一个类。
      
解释：
- 外部类：在嵌套过程中外面的类 。
- 内部类：在嵌套过程中里面的类。
外部类和内部类是一对相对的概念。
      
分类：
- 成员内部类
   - 实例成员内部类 
   - 静态成员内部类
- 局部内部类 
  - 标准局部内部类 
  - 匿名局部内部类
        
技巧：
1. 关注内部类的学习目的。
2. 关注内部类的权限访问级别。
3. 关注内部类的格式。
4. 关注内部类的注意事项。

### 3.2 实例成员内部类(实例内部类)
目的：在实际开发中,某些类不想被本类之外或者本包之外进行访问，只供本类进行使用或本包内部进行使用，现有的知识点满足不了我们需求。
可以将这些类声明在某一个类的成员位置，既然是成员位置，可以使用权限访问级别进行修饰，从而达到限制使用的目的。
且内部类的成员没有静态成员时，选择实例成员内部类。
      
权限：四种权限访问级别都可以,推荐使用private和缺省
      
格式：
```
public class 外部类类名 {
  修饰符 class 内部类类名 {
  }
}
```
注意： 
1. 实例成员内部类对象的创建方式：
   - 当实例成员内部类权限访问级别是"缺省"时:
      - 在本包其它类中，后期需要使用外部类对象时：
        - `外部类类名 外部类对象名 = new 外部类类名(实参);` 
        - `外部类类名.内部类类名 内部类对象名 = 外部类对象名.new 内部类类名(实参);`
      - 在本包其它类中,后期不需要使用外部类对象时：
        - `外部类类名.内部类类名 内部类对象名 = new 外部类类名(实参).new 内部类类名(实参);`
      - 在外部类的构造器中或实例方法中(不推荐)。
        - `内部类类名 对象名 = new 内部类类名();` 
   - 当实例成员内部类权限访问级别是"private"时:
     - 在外部类的构造器中或实例方法中：`内部类类名 对象名 = new 内部类类名();`
2. 在实例成员内部类中不能声明静态成员，如果强行进行声明，需要将实例成员内部类更改为"静态成员内部类"。
3. 在外部类中可以访问内部类的私有成员。
4. 当内部类的实例变量或局部变量和外部类的实例变量或外部类父类的实例变量发生同名的时候，需要使用`外部类类名.this`和`外部类类名.super`进行区分

### 3.3 this和super的第四种用法
this关键字的第四种用法
- 场景：内部类的构造器中或实例方法中。
      
- 格式：
  - `外部类类名.this.实例变量名;` 
  - `外部类类名.this.实例方法名(实参);`
       
- 作用：
  1. 用来区分同名的外部类实例变量和内部类实例变量或局部变量；
  2. 用来区分同名的外部类实例方法和内部类实例方法
          
- 含义：哪个对象调用`外部类类名.this`所在的构造器或实例方法，`外部类类名.this`就代码哪个对象的外部类对象。

super关键字的第四种用法：
- 场景：内部类的构造器中或实例方法中。
      
- 格式：
  - `外部类类名.super.实例变量名;` 
  - `外部类类名.super.实例方法名(实参);`
        
- 作用：
  1. 用来区分同名的外部类父类的实例变量和内部类实例变量或局部变量 
  2. 用来区分同名的外部类父类的实例方法和内部类实例方法

- 含义：哪个对象调用`外部类类名.super`所在的构造器或实例方法，`外部类类名.super`就代码哪个对象外部类对象的父类引用。

### 3.4 静态成员内部类（静态内部类）
目的：在实际开发中，某些类不想被本类之外或者本包之外进行访问，只供本类进行使用或本包内部进行使用，现有的知识点满足不了我们需求。
   可以将这些类声明在某一个类的成员位置，既然是成员位置，可以使用权限访问级别进行修饰，从而达到限制使用的目的。
   且内部类的成员含有静态成员时，选择静态成员内部类。
      
权限：四种权限访问级别都可以，推荐使用private和缺省
      
格式：
```
public class 外部类类名 {
  修饰符 static class 内部类类名 {

  }
}
```
          
注意：
1. 在静态成员内部类中既可以声明实例成员，也可以声明静态成员。
2. 静态成员内部类中的实例成员如果进行获取，参考实例成员内部类
3. 在外部类中可以访问内部类的私有成员

### 3.5 标准局部内部类（局部内部类）
目的：
1. 学习标准局部内部类为了学习匿名局部内部类做铺垫
2. 笔试题
      
权限：只能缺省
      
格式：
```
public class 外部类类名 {
  修饰符 返回类型 方法名 () {
    class 内部类类名 {
    
    }
  }
}
```

注意
1. 标准局部内部类可以使用abstract或final进行修饰，不能使用static进行修饰。
2. 创建标准局部内部类对象只能在标准局部内部类所属方法中，且创建对象的代码必须在标准局部内部类的下面。
3. 当标准局部内部类的实例变量或局部变量和标准局部内部类所属方法的外部类局部变量发生同名的时候，在标准局部内部类中无法获取该同名的外部类局部变量。
4. 外部类的局部变量如果在所属方法的标准局部内部类中进行使用，该外部类局部变量无法在方法中进行更改，一旦在局部内部类中进行使用，JVM的编译器隐式添加final关键字进行修饰。

### 3.6 匿名局部内部类(匿名内部类)
目的：
1. 针对接口的使用进行简化操作
2. 学习匿名内部类是学习"Lambda表达式"的前提条件
      
格式：
```
接口名 接口实现类对象名 = new 接口名(){
  接口实现类的类体
};
```
          
注意：匿名内部类匿名的是"接口的实现类"
      
好处：在实际应用中，调用抽象父类或者父接口作为形参的方法时，无需声明该抽象父类的子类或该接口的实现类。
直接传递给抽象父类或父接口的匿名内部类即可，匿名内部类即该抽象父类的子类对象或该父接口的实现类对象。

## 4. 包装类
### 4.1 概念
含义：八种基本类型对应的引用类型形式
      
分类：
1. 整数型：Byte、Short、Integer、Long 
2. 浮点型：Float、Double 
3. 字符型：Character 
4. 布尔型：Boolean

目的:
1. 基本类型和包装类型之间的转换
2. 基本类型和字符串类型之间的转换
3. 笔试题和面试题

### 4.2 装箱和拆箱
基本类型和包装类型之间的转换（装箱和拆箱）

装箱：将基本类型的数据转换成包装类型的对象
      
拆箱：将包装类型的对象转换成基本类型的数据

装箱方式：
1. 包装类型以基本类型作为形参的构造器
2. 包装类型以基本类型作为形参的静态方法valueOf()
3. 自动装箱(JDK5.0)(推荐)。由JVM隐式调用包装类型以基本类型作为形参的静态方法valueOf()

拆箱方式：
1. 包装类型的实例方法xxxValue()(备注:xxx包装类型对应基本类型)
2. 自动拆箱(JDK5.0)(推荐)。由JVM隐式调用包装类型的实例方法xxxValue()

### 4.3 基本类型和字符串类型之间的转换
将基本类型的数据转换成字符串类型的对象
1. 字符串连接符
2. 包装类型的实例方法toString()
3. 包装类型以包装类型对应的基本类型作为形参的静态方法toString()
4. String类以基本类型作为形参的静态方法valueOf()(推荐)
 
将字符串类型的对象转换成基本类型的数据
1. 包装类型以字符串为形参的构造器,在进行拆箱操作
2. 包装类型以字符串为形参的静态方法parseXxx()(备注:Xxx待装换基本类型)(推荐)

注意事项：
1. 将字符串类型的对象转换成基本类型的数据时，""中的内容必须在待转换基本类型的取值范围
2. 包装类型Character并没有提供将字符串类型的对象转换成char类型数据的方式