package example.innerclass.demo02;

/**
 * @ClassName InnerClassDemo02
 * @Description 此类用于演示功能
 * @Author Shark
 * @DateTime 2022年07月09日 08时40分00秒
 * @Version 1.0
 *
 * 实例成员内部类(实例内部类)
 *      目的:
 *          在实际开发中,某些类不想被本类之外或者本包之外进行访问,只供本类进行使用或本包内部进行使用,现有的知识点满足不了我们
 *          需求,可以将这些类声明在某一个类的成员位置,既然是成员位置,可以使用权限访问级别进行修饰,从而达到限制使用的目的,且内
 *          部类的成员没有静态成员时,选择实例成员内部类
 *      权限:
 *          四种权限访问级别都可以,推荐使用private和缺省
 *      格式:
 *          public class 外部类类名 {
 *              修饰符 class 内部类类名 {
 *
 *              }
 *          }
 *      注意
 *          1.实例成员内部类对象的创建方式
 *              当实例成员内部类权限访问级别是"缺省"时:
 *                  (1)在本包其它类中,后期需要使用外部类对象时
 *                      外部类类名 外部类对象名 = new 外部类类名(实参);
 *                      外部类类名.内部类类名 内部类对象名 = 外部类对象名.new 内部类类名(实参);
 *                  (2)在本包其它类中,后期不需要使用外部类对象时
 *                      外部类类名.内部类类名 内部类对象名 = new 外部类类名(实参).new 内部类类名(实参);
 *                  (3)在外部类的构造器中或实例方法中(不推荐)
 *                      内部类类名 对象名 = new 内部类类名();
 *             当实例成员内部类权限访问级别是"private"时:
 *                  在外部类的构造器中或实例方法中
 *                        内部类类名 对象名 = new 内部类类名();
 *          2.在实例成员内部类中不能声明静态成员,如果强行进行声明,需要将实例成员内部类更改为"静态成员内部类"
 *          3.在外部类中可以访问内部类的私有成员
 *          4.当内部类的实例变量或局部变量和外部类的实例变量或外部类父类的实例变量发生同名的时候,需要使用"外部类类名.this"和
 *          "外部类类名.super"进行区分
 *
 */
public class InnerClassDemo02 {
    public static void main(String[] args) {
        /*//创建外部类类对象
        Outer outer = new Outer();
        //根据外部类对象创建内部类
        Outer.Inner inner = outer.new Inner();

        //直接创建内部类对象
        inner = new Outer().new Inner();*/


        //创建外部类类对象
        Outer outer = new Outer();

        outer.method();
    }
}
