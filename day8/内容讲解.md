## 1. API文档
### 1.1 API(应用程序接口)
含义：提供的类和接口

### 1.2 Java API:
含义：Java系统中提供的类和接口

### 1.3 Java API文档:
含义：查询Java系统中提供的类和接口的文档
关注点：
1. 如果查询类：
   - 类的特点
   - 类的位置。注意:如果是java.lang,无需进行导包
   - 类的构造器 
   - 类的方法
2. 如果查询接口:
   - 接口的特点
   - 接口的位置
   - 接口的方法

## 2. import关键字
含义：导包
位置：package后面、class前面 
格式： 
```
import 包名.类名;
import 包名.;
```

## 3. 面向对象
### 3.1 匿名对象
含义：没有名字的对象
      
格式：`new 类名(实参);`
      
好处：降低对象在内存中的时间，提高内存的使用率。
      
弊端：匿名对象只能使用唯一的一次。

### 3.2 对象数组
含义：存储对象的数组

初始化：
1. 动态初始化：
   - `类名[] 数组名 = new 类名[数组长度];`
2. 静态初始化：
   - `类名[] 数组名 = new 类名[]{对象名1,对象名2,......,对象名n};`
   - `类名[] 数组名 = {对象名1,对象名2,......,对象名n};`

### 3.3 构造器代码块
位置：在类中代码块外 

格式：
```
{
  所有构造器中相同的内容
}
```
 
特点:
1. 构造器代码块优先于构造器中的显式代码执行
2. 将所有构造器中相同的内容抽取到构造器代码块，在实例初始化过程中的第二阶段调用构造器代码块

### 3.4 this关键字的第二种用法:
场景：（子类的）构造器中

格式：`this(实参);`
      
作用：调用本类中其它的构造器完成对象成员的初始化操作
      
含义：当构造器无法进行对象成员初始化时，通过this(实参)调用其它的构造器完成对象成员的初始化

this关键字第二种用法的注意事项： 
1. this（实参）必须在构造器中的第一行，否则编译报错。
2. 一旦构造器中含有this（实参），该构造器不会进行实例成员的初始化操作（构造器中第一阶段和第二阶段做的事情不会执行）。

## 4. 类的静态属性
### 4.1 static关键字:
含义：静态的、共享的
      
修饰：成员变量、成员常量、成员方法、成员内部类、成员代码块
      
特点：
1. 被static关键字修饰的内容不再属于对象，而是归属于类，会被这个类创建的所有对象所共享。
2. 被static关键字修饰的内容会随着类的加载而加载，只能加载唯一的一次。

### 4.2  静态变量
含义：被static关键字修饰的成员变量
      
格式：`修饰符 static 数据类型 变量名;`
      
特点：被static关键字修饰的成员变量不再属于对象，而是归属于类本身，会被这个类创建的所有对象共享。
      
调用：
```
对象名.静态变量名;
类名.静态变量名;
```

静态变量：声明在类中代码块外，且含有static关键字修饰的成员变量。
实例变量：声明在类中代码块外，且没有static关键字修饰的成员变量。
局部变量：声明在代码块内或者方法声明上的变量。

三种变量的区别
1. 代码中的位置不同:
   - 静态变量:类中代码块外 
   - 实例变量:类中代码块外 
   - 局部变量:代码块内或方法声明上（形参列表）
2. 内存中的位置不同:
   - 静态变量：JDK7.0（包含）之前--方法区；JDK8.0（包含）之后--堆内存
   - 实例变量：堆内存 
   - 局部变量：栈内存
3. 变量是否含有默认值不同:
   - 静态变量：含有默认值 
   - 实例变量：含有默认值
   - 局部变量：没有默认值
4. 代码中的作用域不同:
   - 静态变量：所属类中
   - 实例变量：所属类中（静态成员除外） 
   - 局部变量：所属方法中
5. 内存中的生命周期不同:
   - 静态变量：随着类的加载而加载，随着的类的回收而消失
   - 实例变量：随着对象的创建而加载，随着对象的回收而消失
   - 局部变量：随着方法的调用而加载，随着方法的出栈而消失
6. 加载方式和次数不同
   - 静态变量：随着类的加载而加载，因为类只会加载唯一的一次，也只加载唯一的一次
   - 实例变量：随着对象的创建而加载，每创建一次对象就会加载一次 
   - 局部变量：随着方法的调用而加载，每调用一次方法就会加载一次
7. 修饰符的使用不同
   - 静态变量：程序中各种修饰符可以根据需求进行修饰
   - 实例变量：程序中各种修饰符可以根据需求进行修饰
   - 局部变量：只能使用final进行修饰

### 4.3 静态方法
含义：被static修饰的成员方法
      
格式：`修饰符 static 返回类型 方法名 () {}`
      
特点： 
1. 被static关键字修饰的成员方法不再属于对象，而是归属于类本身，会被这个类创建的所有对象共享
2. 当创建一个对象只是为了使用里面大量的实例方法进行操作，和对象本身无关，导致对象本身在堆内存中一直驻留，浪费内存空间。
   - 在实际应用过程中，可以将这些实例方法修饰成静态的。被static修饰的方法不再属于对象，而是归属于类本身，使用里面的工具方法 
   - 无需再进行对象的创建，直接通过类名即可访问。同时将构造器进行私有化
         
调用：
```
对象名.静态方法名(实参);
类名.静态方法名(实参);(推荐)
```

静态方法的注意事项：
1. 静态方法随着类的加载而加载，而且只加载唯一的一次
   - 静态方法的加载：进静态区，只有唯一的一次
   - 静态方法的调用：进栈内存，可以调用很多次
2. 静态方法可以通过类名调用，也可以通过对象名调用，更推荐使用类名进行调用。
3. 静态方法中不可以使用非静态成员。
4. 静态方法中不可以使用this关键字和super关键字。

### 4.4 静态代码块
含义：被static修饰的代码块
      
格式：
```
static {

}
```
          
目的：
1. 封装工具类，提高部分代码加载时机。
2. 类和实例成员初始化过程的笔试题。
3. 给静态常量进行初始化赋值操作。

注意： 
1. 静态代码块随着类的加载而加载，而且只加载唯一的一次。
2. 静态代码块中不可以使用非静态成员
3. 静态方法中不可以使用this关键字和super关键字

## 5. 设计模式和框架
设计模式：解决某一类问题的固定的解决方案

框架：半成品项目

### 5.1 单例设计模式
      
含义：创建唯一对象的解决方案
      
分类：立即加载模式(饿汉式)、延迟加载模式(懒汉式)

立即加载模式
1. 将创建唯一对象的类构造器进行私有化
2. 在创建唯一对象的类中声明并初始化唯一对象
3. 为了可以在外界进行访问，将其进行static修饰
4. 为了唯一对象的安全性，将其进行private修饰
5. 为了可以在外界进行访问，提供公共获取方式

立即加载模式的弊端：部分场景中，不需要使用对象，但是可能加载该类，导致对象的创建，在一段时间内浪费堆内存中空间。

延迟加载模式 
1. 将创建唯一对象的类构造器进行私有化
2. 在创建唯一对象的类中声明唯一对象变量
3. 为了可以在外界进行访问，将其进行static修饰
4. 为了唯一对象的安全性，将其进行private修饰
5. 为了可以在外界进行访问，提供公共获取方式，并且在第一次获取时创建唯一对象
